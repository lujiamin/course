#### java EE 
- servlet工作原理——完整请求过程
  - 客户端发送请求
  - 容器tomcat创建HttpRequestServlet和HttpResponseServlet对象，交由不同的Servlet线程进行处理 
  - 调用service()中的doPost()或doGet()方法进行处理，返回结果
- MVC模型的优点  
- ORM——对象关系映射
  - 映射配置文件
- MyBatis
  - 利用xml文件配置方式实现Mapper，有一个java接口(定义方法)和一个xml文件(SQL语句)构成
  - DAO层实现接口中的方法。需要调用SqlSession类来开启会话，处理完后要关闭会话
  - SqlSessionFactory加载mybatis-config.xml配置文件，建立和数据库的连接
- MyBatis的使用情况
  - 比Hibernate略微复杂，工作量也稍大
  - MyBatis支持动态SQL，存储过程，灵活易维护
- 动态代理
  - 反射机制——能够实现在运行过程中对类进行装载，增加程序的灵活性，降低模块之间的耦合性。主要功能是：得到一个对象所属的类(Class.forName())和方法；在运行时创建对象并调用方法
  - JDK动态代理——编写服务类和接口，编写代理类，提供绑定和代理方法
  - CGLIB代理  
#### 网络部分
- http协议
  - 无状态：没办法保存客户端信息，无法区分每次请求的区别
  - 无连接：每次只处理一个请求，处理完断开连接，节省传输时间。但是不断建立、断开连接花费时间过多。改进：http1.0中提出持久连接。在请求头中携带keep-Alive
- cookie和session作用
- ajax技术，主要是js中的XmlHttpRequest对象
- TCP
  - 传输层，面向连接，是两个主机中的应用进程互相通信(端口)，面向字节流
  - 对整个报文段进行差错校验和检测。可靠服务，按序接收，协议复杂，效率不高
  - 需要建立连接
  - 流量控制是发送方和接收方，拥塞控制是整个网络的抑制发送端速率的策略
- UDP(用户数据包协议)
  - 面向报文，无连接，不可靠
- Socket(网络间进程的通信，IP地址和端口号)  
- IP(数据报)——网关协议RIP，OSPF，BGP
  - IP组播：一组成员，可以突破物理网络(IGMP网际组管理协议)
  - 移动IP：移动主机，归属代理，外地代理。外地代理提供转交地址，使用隧道技术(隧道：是家代理与外代理之间临时建立的双向数据通道。)
  - VPN(虚拟专用网络)：建立专用网络，进行加密通讯，用于企业网络
  - NAT(网络地址转换)：私有IP和全球IP的转换，端口复用(家用路由器)
#### 数据库部分
- MySQL
  - 数据定义：create(drop) table/view/index
  - 存储过程——是一个T-SQL语句组成的代码块，是一个预编译的代码块。
    - 优点：1.执行效率比较高。2.降低了客户机和服务机的通信量。3.便于集中控制，方便维护
    - 创建：```create procedure xxx @param type output as (sql);// @后面跟参数，指明类型，output表明是返回参数```
    - 执行：execute xxx
    - 修改和删除：alter/drop xxx
  - 索引 
    - 是对数据库表中一列或多列的值进行排序的结构，高效获取数据，增加检索速度
    - 会增加系统开销，插入删除等操作需要更新索引
    - 聚集索引——字典根据拼音检索(开头相同的聚集在一起)
    - 非聚集索引——根据偏旁检索(偏旁相同的对应在不同的页码)
    - 唯一索引——不允许表中任何两行具有相同索引值的索引
    - 定义主键时，自动创建主键索引
    - 何时创建索引：1.搜索特定关键字的行。2.搜索关键字值属于某一范围内的行。3.含like。4.在表1中搜索根据连接谓词与表2的某个行匹配的行。
    - 何时使用索引效率高：符合结果的数据量少的时候使用索引。数据量大的话直接全表扫描。原因：索引存放的是指针，需要进行磁盘I/O操作，数据量大的话使用索引没有优势。
  - 触发器
    - 可以看做是一类特殊的触发器，由事件驱动的特殊过程，保证数据完整性的方法。
    - 功能：1.强化约束(实现比check更复杂的语句)。2.跟踪变化。3.级联运行(对某一操作自动级联影响整个数据库的各项内容)。4.调用存储过程。
    - 跟踪数据库的变化从而做出相应措施
    - ```create trigger xxx on table1 for insert as (sql);// 对于insert操作执行as后面的sql语句```  
  - 事务(Transaction)
    - begin transaction // 事务的开始
    - commit // 事务的提交
    - rollback // 事务的回滚
    - ACID性质：原子性(操作的已提醒)，一致性(满足数据库的完整性约束)，隔离性(一个事务的操作不能被其他事务干扰)，持久性(事务一旦提交，对数据库的更改是持久性的)
  - 锁
    - 死锁：两个及以上的事务都处于等待状态，且都需要另一个事务解除封锁才能继续执行下去
    - 活锁：出现有机会获得锁的事务永远无法获得锁。可以用先来先服务策略预防  
    - 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
    - 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性
  - drop删除整张表，delete只删除表中的数据，用where做条件，truncate保留表删除全部数据   
  - 超键包含候选键和主键。候选键是最小超键，不含冗余元素。主键是唯一和完整标识的数据列或属性的组合。外键：在一个表中存在的另一个表的主键称此表的外键   
  - 三个范式
    - 1NF:字段都是单一属性，不可再分
    - 2NF:所有非关键字都完全依赖于任意一组候选关键字
    - 3NF:2NF基础上，不存在非关键字对任一候选关键字段的传递函数依赖。不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y
- Redis
  - 高性能内存数据库，键值对数据库。支持多种类型的数据结构。周期性写入硬盘  
#### 项目部分
- 推荐系统项目
  - 余弦相似度算法
    - 基于用户：User1 对物品的评分是(1,2,3,4),User2 对物品的评分是(2,2,3,3)，则两者的余弦相似度为(1*2+2*2+3*3+3*3)/(sqrt(1^2+2^2+3^2+4^2)*sqrt(2^2+2^2+3^2+3^2))，即求两个向量的夹角  
    - 基于物品：两个物品不同的人对他们的评分表示成向量，使用平均分进行修正，计算两个物品之间的余弦相似度。
  - 协同过滤算法
    - 基于用户和基于物品都会因数据稀疏影响结果。诞生了基于模型的协同过滤，提取各类特征，形成预测模型。
    - 基于物品的SlopeOne算法，主要是计算两个物品的差别，差别由其他同的人对两者的打分求得。
  - k-means聚类算法：首先选择k个点作为中心点，计算所有点和中心点的距离(利用欧式距离)进行聚类，对每一类中的点求中心点，再次进行聚类，直至中心点不在变化，聚类完成。
#### java
- 堆和栈
  - 堆：存放运行时创建的对象。由垃圾回收器负责
  - 栈：存放基本数据类型和引用变量。存取速度更快，栈的大小和生命周期必须固定
```
    public static void main(String[]args){
        int i = 0; // 存放在栈中
        Rect r = new Rect(3,5); // r存放在栈中，new Rect(3,5)放在堆中
    }
```
- 垃圾回收
  - 功能：分配内存，确保被引用的对象内存不被错误回收，回收不被引用的内存空间
  - 回收算法
    - 引用计数算法：堆中每个对象都有一个引用计数器
    - 压缩回收：将堆中活动的对象移动到堆的一端，则另一端流出空闲空间
    - 按代回收：根据生命周期的长短分为多个子堆，优先收集年幼的对象
- static作用
  - 全局变量
  - 静态方法只能调用静态方法，不需对象创建就能被调用
  - static代码块，独立于成员变量和成员函数
  - static内部类，只能访问外部类中的静态成员和静态方法
- final，finally
  - final修饰的变量不能被更改，修饰的类不能被继承，修饰的方法不允许子类重写
  - finally是异常处理的一部分，最终一定被执行
- 进程通信
  - 共享内存
  - 管道通信：连接两个进程的一个共享文件
  - 消息机制      
  - 套接字(网络进程之间)
- 进程同步
  - 临界区
  - 信号量
  - 消息传递机制  
- 多线程
  - 线程的创建和切换开销更小
  - 多CPU或多核CPU具有多线程的能力  
- java多线程实现
  - 1.继承Thread类，重写run()方法
  - 2.实现Runnable()接口，实现run()方法
  - 使用start()方法开启线程，可以异步调用run()方法。在程序中直接调用run()方法无法实现多线程的目的
  - 多线程同步
    - synchronized关键字
    - wait(),notify()
    - ReentrantLock(重入锁)
  - wait()方法会释放锁，sleep()方法不会释放锁，暂停一段时间自动恢复。   
- TreeMap 
  - 底层由红黑树(近似平衡的二叉查找树)实现——根节点黑色;红色节点不能连续;任何一个节点到树端的任何路径，都含有相同个数的黑色节点 
  - TreeSet是对TreeMap的简单包装
- HashMap
  - 未实现同步，其余跟HashTable类似  
  - 不保证元素有序，与TreeMap不同
  - HashSet是对HashMap的简单包装
- LinkedHashMap
  - 在HashMap基础上将元素用双向链表连接
- PriorityQueue
  - 优先权队列(java每次取最小的元素)，是一个小顶堆
  - 增加元素，向上调整
  - 删除最顶元素时，将最下端的元素移至顶端，进行向下调整    